import * as fs from 'fs';
import ts from 'typescript';
import type {
  AnalyzerIssue,
  DrizzleSchema,
  DrizzleTable,
  DrizzleColumn,
  DbOperation,
  DbColumnValue,
} from '../types.js';
import { extractDbOperations } from '../sql/drizzle-operations.js';
import {
  getTableByName,
  getEnumByName,
  getRequiredColumns,
  isNumericColumn,
  isEnumColumn,
} from '../parsers/drizzle-schema-parser.js';
import { parseFile, walkAst, getLineAndColumn } from '../utils/ast-utils.js';

/**
 * Check persistence operations against Drizzle schema
 */
export function checkPersistence(
  files: string[],
  schema: DrizzleSchema
): AnalyzerIssue[] {
  const issues: AnalyzerIssue[] = [];

  for (const file of files) {
    try {
      const { operations } = extractDbOperations(file);

      for (const operation of operations) {
        const opIssues = validateOperation(operation, schema);
        issues.push(...opIssues);
      }
    } catch {
      // File doesn't exist or can't be parsed - skip it
    }
  }

  // Check for aggregate type assertion issues (sql<number> with COUNT/SUM/etc.)
  issues.push(...checkAggregateTypeAssertions(files));

  return issues;
}

/**
 * Validate a single database operation against the schema
 */
function validateOperation(
  operation: DbOperation,
  schema: DrizzleSchema
): AnalyzerIssue[] {
  const issues: AnalyzerIssue[] = [];

  // Find the table in the schema
  const table = getTableByName(schema, operation.tableName);
  if (!table) {
    // #1: Unknown table reference
    issues.push({
      category: 'drizzle',
      severity: 'error',
      message: `Table '${operation.tableName}' not found in Drizzle schema`,
      location: operation.location,
      code: `db.${operation.type}(${operation.tableName})`,
      suggestion: `Check the table name matches an export in the schema file`,
    });
    return issues;
  }

  // Only validate inserts for missing required columns
  if (operation.type === 'insert') {
    const missingColumnIssues = checkMissingRequiredColumns(operation, table);
    issues.push(...missingColumnIssues);
  }

  // #7: Write to auto-generated column on insert
  if (operation.type === 'insert') {
    const autoGenIssues = checkAutoGeneratedColumns(operation, table);
    issues.push(...autoGenIssues);
  }

  // #10: DELETE/UPDATE without WHERE clause
  if (operation.type === 'delete' || operation.type === 'update') {
    if (!operation.hasWhere) {
      issues.push({
        category: 'drizzle',
        severity: 'warning',
        message: `db.${operation.type}(${operation.tableName}) has no .where() clause -- affects all rows`,
        location: operation.location,
        code: `db.${operation.type}(${operation.tableName})${operation.type === 'update' ? '.set({...})' : ''}`,
        suggestion: `Add a .where() clause to target specific rows`,
      });
    }
  }

  // Check all column values for type/enum/null issues
  for (const colValue of operation.columnValues) {
    const column = table.columns.find((c) => c.name === colValue.columnName);
    if (!column) {
      // #2: Unknown column reference
      issues.push({
        category: 'drizzle',
        severity: 'error',
        message: `Column '${colValue.columnName}' not found on table '${operation.tableName}'`,
        location: operation.location,
        code: `${colValue.columnName}: ...`,
        suggestion: `Check column name matches the schema definition for '${operation.tableName}'`,
      });
      continue;
    }

    // #3 and #8: Null to notNull column (insert or update)
    const nullIssue = checkNullToNotNull(colValue, column, operation);
    if (nullIssue) {
      issues.push(nullIssue);
    }

    // Check for enum column issues
    if (isEnumColumn(column)) {
      // Existing: unvalidated external input to enum
      const enumInputIssue = checkEnumValidation(
        colValue,
        column,
        operation,
        schema
      );
      if (enumInputIssue) {
        issues.push(enumInputIssue);
      }

      // #4: Invalid literal enum value
      const enumLiteralIssue = checkEnumLiteralValue(
        colValue,
        column,
        operation,
        schema
      );
      if (enumLiteralIssue) {
        issues.push(enumLiteralIssue);
      }
    }

    // Check for type mismatch (string from formData to integer column)
    const typeIssue = checkTypeMismatch(colValue, column, operation);
    if (typeIssue) {
      issues.push(typeIssue);
    }
  }

  return issues;
}

/**
 * Check if an insert operation is missing required columns
 */
function checkMissingRequiredColumns(
  operation: DbOperation,
  table: DrizzleTable
): AnalyzerIssue[] {
  const issues: AnalyzerIssue[] = [];

  const requiredColumns = getRequiredColumns(table);
  const providedColumns = new Set(
    operation.columnValues.map((cv) => cv.columnName)
  );

  for (const requiredCol of requiredColumns) {
    if (!providedColumns.has(requiredCol.name)) {
      issues.push({
        category: 'drizzle',
        severity: 'error',
        message: `db.insert(${operation.tableName}) missing required column '${requiredCol.name}'`,
        location: operation.location,
        code: `db.insert(${operation.tableName}).values({...})`,
        suggestion: `Add '${requiredCol.name}' to the values object`,
      });
    }
  }

  return issues;
}

/**
 * #7: Check if an insert writes to auto-generated columns
 */
function checkAutoGeneratedColumns(
  operation: DbOperation,
  table: DrizzleTable
): AnalyzerIssue[] {
  const issues: AnalyzerIssue[] = [];

  for (const colValue of operation.columnValues) {
    const column = table.columns.find((c) => c.name === colValue.columnName);
    if (column && column.isAutoGenerated) {
      issues.push({
        category: 'drizzle',
        severity: 'warning',
        message: `Column '${column.name}' is auto-generated (${column.type}) but is explicitly set in insert`,
        location: operation.location,
        code: `${colValue.columnName}: ...`,
        suggestion: `Remove '${column.name}' from the values object to use auto-generation`,
      });
    }
  }

  return issues;
}

/**
 * #3/#8: Check if a null literal is assigned to a notNull column
 */
function checkNullToNotNull(
  colValue: DbColumnValue,
  column: DrizzleColumn,
  operation: DbOperation
): AnalyzerIssue | undefined {
  const source = colValue.dataSource;

  if (source.source === 'literal' && source.type === 'null' && column.notNull) {
    return {
      category: 'drizzle',
      severity: 'error',
      message: `Column '${column.name}' has notNull constraint but receives null`,
      location: operation.location,
      code: `${colValue.columnName}: null`,
      suggestion: `Provide a non-null value for '${column.name}'`,
    };
  }

  return undefined;
}

/**
 * #4: Check if a literal value matches the enum's allowed values
 */
function checkEnumLiteralValue(
  colValue: DbColumnValue,
  column: DrizzleColumn,
  operation: DbOperation,
  schema: DrizzleSchema
): AnalyzerIssue | undefined {
  const source = colValue.dataSource;

  if (source.source !== 'literal' || source.type !== 'string') {
    return undefined;
  }

  const enumDef = column.enumName
    ? getEnumByName(schema, column.enumName)
    : undefined;

  if (!enumDef) {
    return undefined;
  }

  const literalValue = String(source.literalValue);
  if (!enumDef.values.includes(literalValue)) {
    const allowedValues = enumDef.values.map((v) => `'${v}'`).join(', ');
    return {
      category: 'drizzle',
      severity: 'error',
      message: `Enum column '${column.name}' receives invalid value '${literalValue}'`,
      location: operation.location,
      code: `${colValue.columnName}: '${literalValue}'`,
      suggestion: `Allowed values are: ${allowedValues}`,
    };
  }

  return undefined;
}

/**
 * Check if an enum column receives unvalidated external input
 */
function checkEnumValidation(
  colValue: DbColumnValue,
  column: DrizzleColumn,
  operation: DbOperation,
  schema: DrizzleSchema
): AnalyzerIssue | undefined {
  const source = colValue.dataSource;

  // Skip if already validated (via zod or similar)
  if (source.isValidated) {
    return undefined;
  }

  // Skip if it's a literal value (handled by checkEnumLiteralValue)
  if (source.source === 'literal') {
    return undefined;
  }

  // Skip if it's from an unknown/internal source
  if (source.source === 'variable' || source.source === 'unknown') {
    return undefined;
  }

  // Flag if it's from formData, params, or body without validation
  if (
    source.source === 'formData' ||
    source.source === 'params' ||
    source.source === 'body'
  ) {
    const enumDef = column.enumName
      ? getEnumByName(schema, column.enumName)
      : undefined;
    const allowedValues =
      enumDef?.values.map((v) => `'${v}'`).join(', ') || 'enum values';

    return {
      category: 'drizzle',
      severity: 'error',
      message: `Enum column '${column.name}' receives unvalidated external input`,
      location: operation.location,
      code: `${colValue.columnName}: ${source.source}.get('${source.fieldName || colValue.columnName}')`,
      suggestion: `Validate with zod schema or check against allowed values: ${allowedValues}`,
    };
  }

  return undefined;
}

/**
 * Check for type mismatch between data source and column type
 */
function checkTypeMismatch(
  colValue: DbColumnValue,
  column: DrizzleColumn,
  operation: DbOperation
): AnalyzerIssue | undefined {
  const source = colValue.dataSource;

  // Skip if already validated (type coercion would happen in validation)
  if (source.isValidated) {
    return undefined;
  }

  // Skip literals (will be type-checked by TypeScript)
  if (source.source === 'literal') {
    return undefined;
  }

  const externalSources: Array<typeof source.source> = [
    'formData',
    'params',
    'body',
  ];

  // Check for string being passed to numeric column (#9: includes 'body')
  if (isNumericColumn(column) && source.type === 'string') {
    if (externalSources.includes(source.source)) {
      return {
        category: 'drizzle',
        severity: 'error',
        message: `Column '${column.name}' expects ${column.type} but receives string from ${source.source}.get()`,
        location: operation.location,
        code: `${colValue.columnName}: ${source.source}.get('${source.fieldName || colValue.columnName}')`,
        suggestion: `Convert with parseInt(${colValue.columnName}, 10) or Number(${colValue.columnName})`,
      };
    }
  }

  // Check for string being passed to boolean column (#9: includes 'body')
  if (column.type === 'boolean' && source.type === 'string') {
    if (externalSources.includes(source.source)) {
      return {
        category: 'drizzle',
        severity: 'error',
        message: `Column '${column.name}' expects boolean but receives string from ${source.source}.get()`,
        location: operation.location,
        code: `${colValue.columnName}: ${source.source}.get('${source.fieldName || colValue.columnName}')`,
        suggestion: `Convert with Boolean(${colValue.columnName}) or ${colValue.columnName} === 'true'`,
      };
    }
  }

  // #5: Check for string being passed to timestamp/date column
  if (
    (column.type === 'timestamp' || column.type === 'date') &&
    source.type === 'string'
  ) {
    if (externalSources.includes(source.source)) {
      return {
        category: 'drizzle',
        severity: 'warning',
        message: `Column '${column.name}' expects ${column.type} but receives string from ${source.source}.get()`,
        location: operation.location,
        code: `${colValue.columnName}: ${source.source}.get('${source.fieldName || colValue.columnName}')`,
        suggestion: `Convert with new Date(${colValue.columnName})`,
      };
    }
  }

  // #6: Check for string being passed to json/jsonb column
  if (
    (column.type === 'json' || column.type === 'jsonb') &&
    source.type === 'string'
  ) {
    if (externalSources.includes(source.source)) {
      return {
        category: 'drizzle',
        severity: 'warning',
        message: `Column '${column.name}' expects ${column.type} but receives string from ${source.source}.get()`,
        location: operation.location,
        code: `${colValue.columnName}: ${source.source}.get('${source.fieldName || colValue.columnName}')`,
        suggestion: `Convert with JSON.parse(${colValue.columnName})`,
      };
    }
  }

  return undefined;
}

// ============================================================================
// Aggregate Type Assertion Check
// ============================================================================

const AGGREGATE_PATTERN = /\b(SUM|AVG|COUNT|MIN|MAX)\s*\(/i;

/**
 * Check for sql<number> tagged templates containing aggregate functions.
 * Databases return aggregate results as strings, so sql<number>`COUNT(*)`
 * will silently return "123" instead of 123.
 */
function checkAggregateTypeAssertions(files: string[]): AnalyzerIssue[] {
  const issues: AnalyzerIssue[] = [];

  for (const file of files) {
    try {
      const content = fs.readFileSync(file, 'utf-8');
      const sourceFile = parseFile(file, content);

      walkAst(sourceFile, (node) => {
        if (!ts.isTaggedTemplateExpression(node)) return;

        const tag = node.tag;
        if (!ts.isIdentifier(tag) || tag.text !== 'sql') return;

        const typeArgs = node.typeArguments;
        if (!typeArgs || typeArgs.length === 0) return;

        if (!typeContainsNumber(typeArgs[0])) return;

        const templateText = extractRawTemplateText(node.template);
        if (!templateText) return;

        const match = templateText.match(AGGREGATE_PATTERN);
        if (!match) return;

        const aggFunc = match[1].toUpperCase();
        const loc = getLineAndColumn(sourceFile, node.getStart(sourceFile));
        const snippet = content
          .slice(node.getStart(sourceFile), node.getEnd())
          .replace(/\s+/g, ' ')
          .trim();

        issues.push({
          category: 'drizzle',
          severity: 'error',
          message: `sql<number> with ${aggFunc}() -- database returns string, not number`,
          location: { file, line: loc.line, column: loc.column },
          code: snippet.length > 120 ? snippet.slice(0, 117) + '...' : snippet,
          suggestion: `Cast the result: Number(result) or use sql<string> and convert explicitly`,
        });
      });
    } catch {
      // Skip unparseable files
    }
  }

  return issues;
}

/**
 * Check if a TypeNode contains the `number` type
 */
function typeContainsNumber(typeNode: ts.TypeNode): boolean {
  if (typeNode.kind === ts.SyntaxKind.NumberKeyword) {
    return true;
  }

  if (ts.isUnionTypeNode(typeNode)) {
    return typeNode.types.some((t) => typeContainsNumber(t));
  }

  if (ts.isIntersectionTypeNode(typeNode)) {
    return typeNode.types.some((t) => typeContainsNumber(t));
  }

  if (ts.isTypeLiteralNode(typeNode)) {
    for (const member of typeNode.members) {
      if (ts.isPropertySignature(member) && member.type) {
        if (typeContainsNumber(member.type)) {
          return true;
        }
      }
    }
  }

  return false;
}

/**
 * Extract raw text from a template literal (head + all span literals)
 */
function extractRawTemplateText(
  template: ts.TemplateLiteral
): string | undefined {
  if (ts.isNoSubstitutionTemplateLiteral(template)) {
    return template.text;
  }
  if (ts.isTemplateExpression(template)) {
    let result = template.head.text;
    for (const span of template.templateSpans) {
      result += '___';
      result += span.literal.text;
    }
    return result;
  }
  return undefined;
}
