import { describe, it, expect } from 'vitest';
import * as path from 'path';
import { checkPersistence } from '../src/checks/persistence-check.js';
import { parseDrizzleSchema } from '../src/parsers/drizzle-schema-parser.js';
import { extractDbOperations } from '../src/parsers/action-parser.js';

const fixturesDir = path.join(__dirname, 'fixtures/sample-app');
const schemaPath = path.join(fixturesDir, 'db/schema.ts');

describe('drizzle-schema-parser', () => {
  it('should parse table definitions', () => {
    const schema = parseDrizzleSchema(schemaPath);

    expect(schema.tables).toHaveLength(2);

    const usersTable = schema.tables.find((t) => t.name === 'users');
    expect(usersTable).toBeDefined();
    expect(usersTable!.sqlName).toBe('users');
    expect(usersTable!.columns.length).toBeGreaterThan(0);
  });

  it('should parse enum definitions', () => {
    const schema = parseDrizzleSchema(schemaPath);

    expect(schema.enums).toHaveLength(1);
    expect(schema.enums[0].name).toBe('statusEnum');
    expect(schema.enums[0].sqlName).toBe('status');
    expect(schema.enums[0].values).toEqual(['active', 'pending', 'closed']);
  });

  it('should identify required columns', () => {
    const schema = parseDrizzleSchema(schemaPath);

    const usersTable = schema.tables.find((t) => t.name === 'users');
    const requiredColumns = usersTable!.columns.filter((c) => c.isRequired);

    // name, email, and status are required (notNull without default)
    expect(requiredColumns.map((c) => c.name).sort()).toEqual(
      ['email', 'name', 'status'].sort()
    );
  });

  it('should identify auto-generated columns', () => {
    const schema = parseDrizzleSchema(schemaPath);

    const usersTable = schema.tables.find((t) => t.name === 'users');
    const idColumn = usersTable!.columns.find((c) => c.name === 'id');

    expect(idColumn).toBeDefined();
    expect(idColumn!.type).toBe('serial');
    expect(idColumn!.isAutoGenerated).toBe(true);
    expect(idColumn!.isRequired).toBe(false);
  });

  it('should identify columns with defaults', () => {
    const schema = parseDrizzleSchema(schemaPath);

    const usersTable = schema.tables.find((t) => t.name === 'users');
    const createdAtColumn = usersTable!.columns.find(
      (c) => c.name === 'createdAt'
    );

    expect(createdAtColumn).toBeDefined();
    expect(createdAtColumn!.hasDefault).toBe(true);
    expect(createdAtColumn!.isRequired).toBe(false);
  });

  it('should identify enum columns', () => {
    const schema = parseDrizzleSchema(schemaPath);

    const usersTable = schema.tables.find((t) => t.name === 'users');
    const statusColumn = usersTable!.columns.find((c) => c.name === 'status');

    expect(statusColumn).toBeDefined();
    expect(statusColumn!.type).toBe('enum');
    expect(statusColumn!.enumName).toBe('statusEnum');
  });
});

describe('action-parser db operations', () => {
  it('should extract db.insert operations', () => {
    const filePath = path.join(fixturesDir, 'app/routes/user-create.tsx');
    const { operations } = extractDbOperations(filePath);

    expect(operations).toHaveLength(1);
    expect(operations[0].type).toBe('insert');
    expect(operations[0].tableName).toBe('users');
  });

  it('should extract column values from insert', () => {
    const filePath = path.join(fixturesDir, 'app/routes/user-create.tsx');
    const { operations } = extractDbOperations(filePath);

    expect(operations[0].columnValues.length).toBeGreaterThan(0);

    const nameCol = operations[0].columnValues.find(
      (cv) => cv.columnName === 'name'
    );
    expect(nameCol).toBeDefined();
  });

  it('should track formData sources', () => {
    const filePath = path.join(fixturesDir, 'app/routes/user-create.tsx');
    const { operations } = extractDbOperations(filePath);

    const nameCol = operations[0].columnValues.find(
      (cv) => cv.columnName === 'name'
    );
    expect(nameCol?.dataSource.source).toBe('formData');
    expect(nameCol?.dataSource.type).toBe('string');
  });

  it('should track Number() conversions', () => {
    const filePath = path.join(fixturesDir, 'app/routes/order-create.tsx');
    const { operations } = extractDbOperations(filePath);

    const userIdCol = operations[0].columnValues.find(
      (cv) => cv.columnName === 'userId'
    );
    expect(userIdCol?.dataSource.source).toBe('formData');
    expect(userIdCol?.dataSource.type).toBe('number');
  });

  it('should track validated data sources', () => {
    const filePath = path.join(fixturesDir, 'app/routes/user-update.tsx');
    const { operations } = extractDbOperations(filePath);

    // All columns should come from validated data (schema.parse)
    expect(operations[0].columnValues.length).toBeGreaterThan(0);
    for (const col of operations[0].columnValues) {
      expect(col.dataSource.isValidated).toBe(true);
    }
  });
});

describe('persistence-check', () => {
  describe('missing required columns', () => {
    it('should detect missing required column in insert', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/user-create.tsx');

      const issues = checkPersistence([filePath], schema);

      const missingEmailIssue = issues.find((i) =>
        i.message.includes("missing required column 'email'")
      );
      expect(missingEmailIssue).toBeDefined();
      expect(missingEmailIssue!.severity).toBe('error');
      expect(missingEmailIssue!.category).toBe('drizzle');
    });
  });

  describe('enum validation', () => {
    it('should detect unvalidated enum input', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/order-create.tsx');

      const issues = checkPersistence([filePath], schema);

      const enumIssue = issues.find((i) =>
        i.message.includes("Enum column 'status'")
      );
      expect(enumIssue).toBeDefined();
      expect(enumIssue!.severity).toBe('error');
      expect(enumIssue!.suggestion).toContain('active');
      expect(enumIssue!.suggestion).toContain('pending');
      expect(enumIssue!.suggestion).toContain('closed');
    });

    it('should not flag validated enum input', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/user-update.tsx');

      const issues = checkPersistence([filePath], schema);

      const enumIssues = issues.filter((i) =>
        i.message.includes('Enum column')
      );
      expect(enumIssues).toHaveLength(0);
    });
  });

  describe('type mismatch', () => {
    it('should detect string to integer type mismatch', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/user-type-mismatch.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const typeIssue = issues.find(
        (i) =>
          i.message.includes("'age'") &&
          i.message.includes('expects integer') &&
          i.message.includes('string')
      );
      expect(typeIssue).toBeDefined();
      expect(typeIssue!.severity).toBe('error');
      expect(typeIssue!.suggestion).toContain('parseInt');
    });

    it('should not flag properly converted types', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/user-correct-types.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const typeIssues = issues.filter((i) =>
        i.message.includes('expects integer')
      );
      expect(typeIssues).toHaveLength(0);
    });
  });

  describe('safe patterns', () => {
    it('should not flag validated inserts', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/user-update.tsx');

      const issues = checkPersistence([filePath], schema);

      // No issues expected - all values are validated via zod
      expect(issues).toHaveLength(0);
    });

    it('should not flag inserts with literal enum values', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/user-correct-types.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const enumIssues = issues.filter((i) =>
        i.message.includes('Enum column')
      );
      expect(enumIssues).toHaveLength(0);
    });
  });
});
