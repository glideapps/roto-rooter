import { describe, it, expect } from 'vitest';
import * as path from 'path';
import { checkPersistence } from '../src/checks/persistence-check.js';
import { parseDrizzleSchema } from '../src/parsers/drizzle-schema-parser.js';
import { extractDbOperations } from '../src/sql/drizzle-operations.js';

const fixturesDir = path.join(__dirname, 'fixtures/sample-app');
const schemaPath = path.join(fixturesDir, 'db/schema.ts');

describe('drizzle-schema-parser', () => {
  it('should parse table definitions', () => {
    const schema = parseDrizzleSchema(schemaPath);

    expect(schema.tables).toHaveLength(3);

    const usersTable = schema.tables.find((t) => t.name === 'users');
    expect(usersTable).toBeDefined();
    expect(usersTable!.sqlName).toBe('users');
    expect(usersTable!.columns.length).toBeGreaterThan(0);
  });

  it('should parse enum definitions', () => {
    const schema = parseDrizzleSchema(schemaPath);

    expect(schema.enums).toHaveLength(1);
    expect(schema.enums[0].name).toBe('statusEnum');
    expect(schema.enums[0].sqlName).toBe('status');
    expect(schema.enums[0].values).toEqual(['active', 'pending', 'closed']);
  });

  it('should identify required columns', () => {
    const schema = parseDrizzleSchema(schemaPath);

    const usersTable = schema.tables.find((t) => t.name === 'users');
    const requiredColumns = usersTable!.columns.filter((c) => c.isRequired);

    // name, email, and status are required (notNull without default)
    expect(requiredColumns.map((c) => c.name).sort()).toEqual(
      ['email', 'name', 'status'].sort()
    );
  });

  it('should identify auto-generated columns', () => {
    const schema = parseDrizzleSchema(schemaPath);

    const usersTable = schema.tables.find((t) => t.name === 'users');
    const idColumn = usersTable!.columns.find((c) => c.name === 'id');

    expect(idColumn).toBeDefined();
    expect(idColumn!.type).toBe('serial');
    expect(idColumn!.isAutoGenerated).toBe(true);
    expect(idColumn!.isRequired).toBe(false);
  });

  it('should identify columns with defaults', () => {
    const schema = parseDrizzleSchema(schemaPath);

    const usersTable = schema.tables.find((t) => t.name === 'users');
    const createdAtColumn = usersTable!.columns.find(
      (c) => c.name === 'createdAt'
    );

    expect(createdAtColumn).toBeDefined();
    expect(createdAtColumn!.hasDefault).toBe(true);
    expect(createdAtColumn!.isRequired).toBe(false);
  });

  it('should identify enum columns', () => {
    const schema = parseDrizzleSchema(schemaPath);

    const usersTable = schema.tables.find((t) => t.name === 'users');
    const statusColumn = usersTable!.columns.find((c) => c.name === 'status');

    expect(statusColumn).toBeDefined();
    expect(statusColumn!.type).toBe('enum');
    expect(statusColumn!.enumName).toBe('statusEnum');
  });

  it('should parse events table with date and jsonb columns', () => {
    const schema = parseDrizzleSchema(schemaPath);

    const eventsTable = schema.tables.find((t) => t.name === 'events');
    expect(eventsTable).toBeDefined();

    const startDate = eventsTable!.columns.find((c) => c.name === 'startDate');
    expect(startDate).toBeDefined();
    expect(startDate!.type).toBe('date');

    const scheduledAt = eventsTable!.columns.find(
      (c) => c.name === 'scheduledAt'
    );
    expect(scheduledAt).toBeDefined();
    expect(scheduledAt!.type).toBe('timestamp');

    const metadata = eventsTable!.columns.find((c) => c.name === 'metadata');
    expect(metadata).toBeDefined();
    expect(metadata!.type).toBe('jsonb');
  });
});

describe('action-parser db operations', () => {
  it('should extract db.insert operations', () => {
    const filePath = path.join(fixturesDir, 'app/routes/user-create.tsx');
    const { operations } = extractDbOperations(filePath);

    expect(operations).toHaveLength(1);
    expect(operations[0].type).toBe('insert');
    expect(operations[0].tableName).toBe('users');
  });

  it('should extract column values from insert', () => {
    const filePath = path.join(fixturesDir, 'app/routes/user-create.tsx');
    const { operations } = extractDbOperations(filePath);

    expect(operations[0].columnValues.length).toBeGreaterThan(0);

    const nameCol = operations[0].columnValues.find(
      (cv) => cv.columnName === 'name'
    );
    expect(nameCol).toBeDefined();
  });

  it('should track formData sources', () => {
    const filePath = path.join(fixturesDir, 'app/routes/user-create.tsx');
    const { operations } = extractDbOperations(filePath);

    const nameCol = operations[0].columnValues.find(
      (cv) => cv.columnName === 'name'
    );
    expect(nameCol?.dataSource.source).toBe('formData');
    expect(nameCol?.dataSource.type).toBe('string');
  });

  it('should track Number() conversions', () => {
    const filePath = path.join(fixturesDir, 'app/routes/order-create.tsx');
    const { operations } = extractDbOperations(filePath);

    const userIdCol = operations[0].columnValues.find(
      (cv) => cv.columnName === 'userId'
    );
    expect(userIdCol?.dataSource.source).toBe('formData');
    expect(userIdCol?.dataSource.type).toBe('number');
  });

  it('should track validated data sources', () => {
    const filePath = path.join(fixturesDir, 'app/routes/user-update.tsx');
    const { operations } = extractDbOperations(filePath);

    // All columns should come from validated data (schema.parse)
    expect(operations[0].columnValues.length).toBeGreaterThan(0);
    for (const col of operations[0].columnValues) {
      expect(col.dataSource.isValidated).toBe(true);
    }
  });

  it('should detect hasWhere on delete with where', () => {
    const filePath = path.join(fixturesDir, 'app/routes/delete-with-where.tsx');
    const { operations } = extractDbOperations(filePath);

    expect(operations).toHaveLength(1);
    expect(operations[0].type).toBe('delete');
    expect(operations[0].hasWhere).toBe(true);
  });

  it('should detect missing where on delete without where', () => {
    const filePath = path.join(fixturesDir, 'app/routes/delete-no-where.tsx');
    const { operations } = extractDbOperations(filePath);

    expect(operations).toHaveLength(1);
    expect(operations[0].type).toBe('delete');
    expect(operations[0].hasWhere).toBe(false);
  });
});

describe('persistence-check', () => {
  describe('missing required columns', () => {
    it('should detect missing required column in insert', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/user-create.tsx');

      const issues = checkPersistence([filePath], schema);

      const missingEmailIssue = issues.find((i) =>
        i.message.includes("missing required column 'email'")
      );
      expect(missingEmailIssue).toBeDefined();
      expect(missingEmailIssue!.severity).toBe('error');
      expect(missingEmailIssue!.category).toBe('drizzle');
    });
  });

  describe('enum validation', () => {
    it('should detect unvalidated enum input', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/order-create.tsx');

      const issues = checkPersistence([filePath], schema);

      const enumIssue = issues.find((i) =>
        i.message.includes("Enum column 'status'")
      );
      expect(enumIssue).toBeDefined();
      expect(enumIssue!.severity).toBe('error');
      expect(enumIssue!.suggestion).toContain('active');
      expect(enumIssue!.suggestion).toContain('pending');
      expect(enumIssue!.suggestion).toContain('closed');
    });

    it('should not flag validated enum input', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/user-update.tsx');

      const issues = checkPersistence([filePath], schema);

      const enumIssues = issues.filter((i) =>
        i.message.includes('Enum column')
      );
      expect(enumIssues).toHaveLength(0);
    });
  });

  describe('type mismatch', () => {
    it('should detect string to integer type mismatch', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/user-type-mismatch.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const typeIssue = issues.find(
        (i) =>
          i.message.includes("'age'") &&
          i.message.includes('expects integer') &&
          i.message.includes('string')
      );
      expect(typeIssue).toBeDefined();
      expect(typeIssue!.severity).toBe('error');
      expect(typeIssue!.suggestion).toContain('parseInt');
    });

    it('should not flag properly converted types', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/user-correct-types.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const typeIssues = issues.filter((i) =>
        i.message.includes('expects integer')
      );
      expect(typeIssues).toHaveLength(0);
    });
  });

  describe('safe patterns', () => {
    it('should not flag validated inserts', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/user-update.tsx');

      const issues = checkPersistence([filePath], schema);

      // No issues expected - all values are validated via zod
      expect(issues).toHaveLength(0);
    });

    it('should not flag inserts with valid literal enum values', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/user-correct-types.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const enumIssues = issues.filter((i) =>
        i.message.includes('Enum column')
      );
      expect(enumIssues).toHaveLength(0);
    });
  });

  // ========================================================================
  // New checks
  // ========================================================================

  describe('unknown table reference', () => {
    it('should detect table not in schema', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/unknown-table.tsx');

      const issues = checkPersistence([filePath], schema);

      const tableIssue = issues.find((i) =>
        i.message.includes("Table 'widgets' not found")
      );
      expect(tableIssue).toBeDefined();
      expect(tableIssue!.severity).toBe('error');
    });

    it('should not flag known tables', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/user-create.tsx');

      const issues = checkPersistence([filePath], schema);

      const tableIssues = issues.filter((i) =>
        i.message.includes('not found in Drizzle schema')
      );
      expect(tableIssues).toHaveLength(0);
    });
  });

  describe('unknown column reference', () => {
    it('should detect column not on table', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/unknown-column.tsx');

      const issues = checkPersistence([filePath], schema);

      const colIssue = issues.find((i) =>
        i.message.includes("Column 'middleName' not found on table 'users'")
      );
      expect(colIssue).toBeDefined();
      expect(colIssue!.severity).toBe('error');
    });

    it('should not flag known columns', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/user-correct-types.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const colIssues = issues.filter((i) =>
        i.message.includes('not found on table')
      );
      expect(colIssues).toHaveLength(0);
    });
  });

  describe('null to notNull column', () => {
    it('should detect null literal to notNull column on insert', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/null-notnull.tsx');

      const issues = checkPersistence([filePath], schema);

      const nullIssue = issues.find(
        (i) =>
          i.message.includes("'name'") &&
          i.message.includes('notNull') &&
          i.message.includes('null')
      );
      expect(nullIssue).toBeDefined();
      expect(nullIssue!.severity).toBe('error');
    });

    it('should detect null literal to notNull column on update', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/update-null-notnull.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const nullIssue = issues.find(
        (i) =>
          i.message.includes("'name'") &&
          i.message.includes('notNull') &&
          i.message.includes('null')
      );
      expect(nullIssue).toBeDefined();
      expect(nullIssue!.severity).toBe('error');
    });

    it('should not flag null to nullable column', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/user-correct-types.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const nullIssues = issues.filter((i) =>
        i.message.includes('notNull constraint but receives null')
      );
      expect(nullIssues).toHaveLength(0);
    });
  });

  describe('invalid enum literal value', () => {
    it('should detect invalid literal enum value', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/invalid-enum-literal.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const enumIssue = issues.find((i) =>
        i.message.includes("invalid value 'archived'")
      );
      expect(enumIssue).toBeDefined();
      expect(enumIssue!.severity).toBe('error');
      expect(enumIssue!.suggestion).toContain('active');
      expect(enumIssue!.suggestion).toContain('pending');
      expect(enumIssue!.suggestion).toContain('closed');
    });

    it('should not flag valid literal enum value', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/user-correct-types.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const enumIssues = issues.filter((i) =>
        i.message.includes('invalid value')
      );
      expect(enumIssues).toHaveLength(0);
    });
  });

  describe('string to timestamp/date', () => {
    it('should warn on string from formData to timestamp column', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/string-to-timestamp.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const timestampIssue = issues.find(
        (i) =>
          i.message.includes("'scheduledAt'") &&
          i.message.includes('expects timestamp')
      );
      expect(timestampIssue).toBeDefined();
      expect(timestampIssue!.severity).toBe('warning');
      expect(timestampIssue!.suggestion).toContain('new Date');
    });

    it('should warn on string from formData to date column', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/string-to-timestamp.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const dateIssue = issues.find(
        (i) =>
          i.message.includes("'startDate'") &&
          i.message.includes('expects date')
      );
      expect(dateIssue).toBeDefined();
      expect(dateIssue!.severity).toBe('warning');
      expect(dateIssue!.suggestion).toContain('new Date');
    });

    it('should not warn on timestamp columns with defaults', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/user-create.tsx');

      const issues = checkPersistence([filePath], schema);

      const timestampIssues = issues.filter((i) =>
        i.message.includes('expects timestamp')
      );
      expect(timestampIssues).toHaveLength(0);
    });
  });

  describe('string to json/jsonb', () => {
    it('should warn on string from formData to jsonb column', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/string-to-json.tsx');

      const issues = checkPersistence([filePath], schema);

      const jsonIssue = issues.find(
        (i) =>
          i.message.includes("'metadata'") &&
          i.message.includes('expects jsonb')
      );
      expect(jsonIssue).toBeDefined();
      expect(jsonIssue!.severity).toBe('warning');
      expect(jsonIssue!.suggestion).toContain('JSON.parse');
    });
  });

  describe('write to auto-generated column', () => {
    it('should warn when explicitly setting serial column', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/write-autogen.tsx');

      const issues = checkPersistence([filePath], schema);

      const autoGenIssue = issues.find(
        (i) =>
          i.message.includes("'id'") && i.message.includes('auto-generated')
      );
      expect(autoGenIssue).toBeDefined();
      expect(autoGenIssue!.severity).toBe('warning');
      expect(autoGenIssue!.suggestion).toContain('Remove');
    });

    it('should not warn when serial column is omitted', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/user-create.tsx');

      const issues = checkPersistence([filePath], schema);

      const autoGenIssues = issues.filter((i) =>
        i.message.includes('auto-generated')
      );
      expect(autoGenIssues).toHaveLength(0);
    });
  });

  describe('delete/update without where', () => {
    it('should warn on delete without where clause', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/delete-no-where.tsx');

      const issues = checkPersistence([filePath], schema);

      const whereIssue = issues.find(
        (i) =>
          i.message.includes('db.delete(users)') &&
          i.message.includes('no .where()')
      );
      expect(whereIssue).toBeDefined();
      expect(whereIssue!.severity).toBe('warning');
    });

    it('should warn on update without where clause', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(fixturesDir, 'app/routes/update-no-where.tsx');

      const issues = checkPersistence([filePath], schema);

      const whereIssue = issues.find(
        (i) =>
          i.message.includes('db.update(users)') &&
          i.message.includes('no .where()')
      );
      expect(whereIssue).toBeDefined();
      expect(whereIssue!.severity).toBe('warning');
    });

    it('should not warn on delete with where clause', () => {
      const schema = parseDrizzleSchema(schemaPath);
      const filePath = path.join(
        fixturesDir,
        'app/routes/delete-with-where.tsx'
      );

      const issues = checkPersistence([filePath], schema);

      const whereIssues = issues.filter((i) =>
        i.message.includes('no .where()')
      );
      expect(whereIssues).toHaveLength(0);
    });
  });
});
